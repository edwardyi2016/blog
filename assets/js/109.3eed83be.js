(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{183:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"thread"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thread","aria-hidden":"true"}},[t._v("#")]),t._v(" Thread")]),t._v(" "),r("p",[t._v("线程的实现方式之一，继承Thread类。")]),t._v(" "),r("p",[t._v("在"),r("code",[t._v("java.lang")]),t._v("包中定义，继承Thread类必须重写run()方法。")]),t._v(" "),r("p",[t._v("创建好了自定义的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run()方法中只是定义需要执行的任务，如果调用run()方法，即相当于在主线程中执行run()方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。新线程创建的过程不会阻塞主线程的后续执行。")])])}],!1,null,null,null);e.default=n.exports}}]);